#include <iostream>
#include <string>
using namespace std;

struct myNode
{
    string data;
    myNode *next;
};

class myStack
{
    myNode *head;
    myNode *undoStack; // stack for undo (stores deleted data)
    myNode *redoStack; // stack for redo (stores undone data)

    // Functions for undo and redo stacks
    void pushUndoStack(string data);
    string popUndoStack();
    void pushRedoStack(string data);
    string popRedoStack();
    void clearRedoStack();

public:
    myStack();
    ~myStack();
    void push();
    void deleteNode();
    void peek();
    void undo();
    void redo();
    void display();
};

myNode *getNode();

myStack::myStack()
{
    head = NULL;
    undoStack = NULL;
    redoStack = NULL;
}

myStack::~myStack()
{
    // delete main stack
    while (head)
    {
        myNode *p = head->next;
        delete head;
        head = p;
    }
    // delete undo stack
    while (undoStack)
    {
        myNode *p = undoStack->next;
        delete undoStack;
        undoStack = p;
    }
    // delete redo stack
    while (redoStack)
    {
        myNode *p = redoStack->next;
        delete redoStack;
        redoStack = p;
    }
}

void myStack::pushUndoStack(string data)
{
    myNode *t = new myNode;
    t->data = data;
    t->next = undoStack;
    undoStack = t;
}

string myStack::popUndoStack()
{
    if (!undoStack)
        return "";
    myNode *t = undoStack;
    string data = t->data;
    undoStack = undoStack->next;
    delete t;
    return data;
}

void myStack::pushRedoStack(string data)
{
    myNode *t = new myNode;
    t->data = data;
    t->next = redoStack;
    redoStack = t;
}

string myStack::popRedoStack()
{
    if (!redoStack)
        return "";
    myNode *t = redoStack;
    string data = t->data;
    redoStack = redoStack->next;
    delete t;
    return data;
}

void myStack::clearRedoStack()
{
    while (redoStack)
    {
        myNode *t = redoStack;
        redoStack = redoStack->next;
        delete t;
    }
}

void myStack::push()
{
    myNode *t = getNode();
    t->next = head;
    head = t;
    clearRedoStack(); // new push disables redo
}

void myStack::deleteNode()
{
    if (!head)
    {
        cout << "Your list is empty\n";
        return;
    }
    myNode *p = head;
    pushUndoStack(head->data); // save deleted item for undo
    head = head->next;
    delete p;
    clearRedoStack(); // delete disables redo until undo
}

void myStack::peek()
{
    if (!head)
    {
        cout << "Your list is empty\n";
        return;
    }
    cout << "Top element: " << head->data << endl;
}

void myStack::undo()
{
    string data = popUndoStack();
    if (data == "")
    {
        cout << "Nothing to undo.\n";
        return;
    }
    myNode *t = new myNode{data, head};
    head = t;
    pushRedoStack(data); // save for redo
}

void myStack::redo()
{
    string data = popRedoStack();
    if (data == "")
    {
        cout << "Nothing to redo.\n";
        return;
    }
    if (!head)
    {
        cout << "Stack is empty, cannot redo.\n";
        return;
    }
    myNode *p = head;
    if (head->data == data)
    {
        head = head->next;
        delete p;
        pushUndoStack(data); // save back to undo stack
    }
}

void myStack::display()
{
    if (!head)
    {
        cout << "Stack is empty\n";
        return;
    }
    myNode *p = head;
    cout << "Stack contents:\n";
    while (p)
    {
        cout << p->data << endl;
        p = p->next;
    }
}

myNode *getNode()
{
    myNode *t = new myNode;
    cout << "Enter your data: ";
    cin.ignore();
    getline(cin, t->data);
    t->next = NULL;
    return t;
}

int main()
{
    myStack s;
    int choice;

    while (true)
    {
        cout << "\n1.Push\n2.Delete\n3.Peek\n4.Undo\n5.Redo\n6.Display\n7.Quit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice)
        {
        case 1:
            s.push();
            break;
        case 2:
            s.deleteNode();
            s.peek();
            break;
        case 3:
            s.peek();
            break;
        case 4:
            s.undo();
            s.peek();
            break;
        case 5:
            s.redo();
            s.peek();
            break;
        case 6:
            s.display();
            break;
        case 7:
            cout << "Exiting program.\n";
            return 0;
        default:
            cout << "Invalid choice.\n";
        }
    }
}
