// Use of SLL as queue to make myNode management system considering data, weight and priority using enum

#include <iostream>
#include <string>
using namespace std;

// Enum for task priority
enum Priority
{
    LOW,
    MED,
    HIGH
};

struct myNode
{
    string title;
    float weight;
    int time;
    Priority priority;
    myNode *next;
};

class myQueue
{
    myNode *front;
    myNode *rear;

public:
    myQueue();
    myNode *getNode();
    bool isEmpty();
    void create();
    void enqueue();
    void dequeue();
    void peek();
    void display();
};

// Constructor
myQueue::myQueue()
{
    front = NULL;
    rear = NULL;
}

// Create and return new node
myNode *myQueue::getNode()
{
    myNode *t = new myNode;

    cout << "Enter task title: ";
    cin >> t->title;
    cout << "Enter weight: ";
    cin >> t->weight;
    cout << "Enter time required in hours : ";
    cin >> t->time;
    int p;
    cout << "Enter priority (0=Low, 1=Med, 2=High): ";
    cin >> p;
    t->priority = static_cast<Priority>(p); // convert int to enum

    t->next = NULL;
    return t;
}

// Check if queue is empty
bool myQueue::isEmpty()
{
    return front == NULL;
}

// Create multiple tasks
void myQueue::create()
{
    int n;
    cout << "Enter number of tasks to insert: ";
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        enqueue();
    }
}

// Enqueue
void myQueue::enqueue()
{
    myNode *t = getNode();
    if (rear == NULL)
    {
        front = rear = t;
    }
    else
    {
        rear->next = t;
        rear = t;
    }
    cout << "Task \"" << t->title << "\" added to queue.\n";
}

// Dequeue
void myQueue::dequeue()
{
    if (isEmpty())
    {
        cout << "Queue is empty.\n";
        return;
    }
    myNode *t = front;
    cout << "Deleted task: " << t->title << "\n";
    front = front->next;
    if (front == NULL)
        rear = NULL;
    delete t;
}

// Peek (front element)
void myQueue::peek()
{
    if (!isEmpty())
    {
        cout << "Front task → " << front->title
             << " | Weight: " << front->weight
             << " | time required : " << front->time << " hours | Priority ";
        if (front->priority == LOW)
        {
            cout << "Low\n";
        }
        else if (front->priority == MED)
        {
            cout << "Medium\n";
        }
        else
        {
            cout << "High\n";
        }
    }
    else
    {
        cout << "Queue is empty.\n";
    }
}

// Display all tasks
void myQueue::display()
{
    if (isEmpty())
    {
        cout << "Queue is empty.\n";
        return;
    }
    cout << "\n--- Task Queue ---\n";
    myNode *curr = front;
    while (curr != NULL)
    {
        cout << "Task → " << curr->title
             << " | Weight: " << curr->weight
             << " | Time required: " << curr->time << " hours | Priority: ";
        if (curr->priority == LOW)
        {
            cout << "Low\n";
        }
        else if (curr->priority == MED)
        {
            cout << "Medium\n";
        }
        else if (curr->priority == HIGH)
        {
            cout << "High\n";
        }
        curr = curr->next;
    }
}

int main()
{
    myQueue q;
    int choice;

    q.create();

    do
    {
        cout << "\n--- MENU ---\n";
        cout << "1. Add task\n";
        cout << "2. Delete task\n";
        cout << "3. See front task\n";
        cout << "4. Display all tasks\n";
        cout << "5. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;

        switch (choice)
        {
        case 1:
            q.enqueue();
            break;
        case 2:
            q.dequeue();
            break;
        case 3:
            q.peek();
            break;
        case 4:
            q.display();
            break;
        case 5:
            cout << "Exited program.\n";
            break;
        default:
            cout << "Invalid choice.\n";
        }

    } while (choice != 5);

    return 0;
}
