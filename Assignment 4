#include <iostream>
#include <stack>
#include <string>
#include <algorithm>
#include <cctype>
#include <cmath>

using namespace std;

// Operator precedence
int precedence(char op)
{
    if (op == '+' || op == '-')
        return 1;
    if (op == '*' || op == '/')
        return 2;
    if (op == '^')
        return 3;
    return 0;
}

// Check if character is operator
bool isOperator(char c)
{
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '^');
}

// Infix to Postfix Conversion
string infixToPostfix(string infix)
{
    stack<char> s;
    string postfix = "";
    int openParenCount = 0, closeParenCount = 0;

    for (int i = 0; i < infix.length(); i++)
    {
        char ch = infix[i];

        if (isalnum(ch))
        {
            postfix += ch;
        }
        else if (ch == '(')
        {
            s.push(ch);
            openParenCount++;
        }
        else if (ch == ')')
        {
            closeParenCount++;
            if (s.empty())
            {
                cout << "Error: Open parenthesis '(' missing!" << endl;
                return "";
            }

            while (!s.empty() && s.top() != '(')
            {
                postfix += s.top();
                s.pop();
            }

            if (!s.empty() && s.top() == '(')
            {
                s.pop();
            }
            else
            {
                cout << "Error: Open parenthesis '(' missing!" << endl;
                return "";
            }
        }
        else if (isOperator(ch))
        {
            while (!s.empty() && precedence(ch) <= precedence(s.top()))
            {
                postfix += s.top();
                s.pop();
            }
            s.push(ch);
        }
    }

    while (!s.empty())
    {
        if (s.top() == '(' || s.top() == ')')
        {
            cout << "Error: Mismatched parenthesis detected!" << endl;
            return "";
        }
        postfix += s.top();
        s.pop();
    }

    if (openParenCount != closeParenCount)
    {
        cout << "Error: Open/Close parenthesis mismatch!" << endl;
        return "";
    }

    return postfix;
}

// Infix to Prefix Conversion
string infixToPrefix(string infix)
{
    stack<char> s;
    string prefix = "";

    // Reverse the infix expression
    reverse(infix.begin(), infix.end());

    for (int i = 0; i < infix.length(); i++)
    {
        char ch = infix[i];

        // Swap parentheses after reversal
        if (ch == '(')
            ch = ')';
        else if (ch == ')')
            ch = '(';

        if (isalnum(ch))
        {
            prefix += ch;
        }
        else if (ch == '(')
        {
            s.push(ch);
        }
        else if (ch == ')')
        {
            while (!s.empty() && s.top() != '(')
            {
                prefix += s.top();
                s.pop();
            }
            if (!s.empty() && s.top() == '(')
            {
                s.pop();
            }
            else
            {
                cout << "Error: Open parenthesis '(' missing!" << endl;
                return "";
            }
        }
        else if (isOperator(ch))
        {
            while (!s.empty() &&
                   (precedence(ch) < precedence(s.top()) ||
                    (precedence(ch) == precedence(s.top()) && ch == '^')))
            {
                prefix += s.top();
                s.pop();
            }
            s.push(ch);
        }
    }

    while (!s.empty())
    {
        if (s.top() == '(' || s.top() == ')')
        {
            cout << "Error: Mismatched parenthesis detected!" << endl;
            return "";
        }
        prefix += s.top();
        s.pop();
    }

    reverse(prefix.begin(), prefix.end());
    return prefix;
}

// Evaluate Postfix Expression
int evaluatePostfix(string postfix)
{
    stack<int> s;

    for (int i = 0; i < postfix.length(); i++)
    {
        char ch = postfix[i];

        if (isalpha(ch))
        {
            cout << "Enter value of " << ch << ": ";
            int val;
            cin >> val;

            s.push(val);
        }
        else if (isOperator(ch))
        {
            if (s.empty())
            {
                cout << "Error: Stack Empty (insufficient operands)" << endl;
                return 0;
            }
            int b = s.top();
            s.pop();

            if (s.empty())
            {
                cout << "Error: Stack Empty (insufficient operands)" << endl;
                return 0;
            }
            int a = s.top();
            s.pop();

            int res = 0;
            switch (ch)
            {
            case '+':
                res = a + b;
                break;
            case '-':
                res = a - b;
                break;
            case '*':
                res = a * b;
                break;
            case '/':
                res = a / b;
                break;
            case '^':
                res = pow(a, b);
                break;
            }

            s.push(res);
        }
    }

    if (s.empty())
    {
        cout << "Error: Stack Empty (no result available)" << endl;
        return 0;
    }

    return s.top();
}

// Evaluate Prefix Expression
int evaluatePrefix(string prefix)
{
    stack<int> s;

    for (int i = prefix.length() - 1; i >= 0; i--)
    {
        char ch = prefix[i];

        if (isalpha(ch))
        {
            cout << "Enter value of " << ch << ": ";
            int val;
            cin >> val;

            s.push(val);
        }
        else if (isOperator(ch))
        {
            if (s.empty())
            {
                cout << "Error: Stack Empty (insufficient operands)" << endl;
                return 0;
            }
            int a = s.top();
            s.pop();

            if (s.empty())
            {
                cout << "Error: Stack Empty (insufficient operands)" << endl;
                return 0;
            }
            int b = s.top();
            s.pop();

            int res = 0;
            switch (ch)
            {
            case '+':
                res = a + b;
                break;
            case '-':
                res = a - b;
                break;
            case '*':
                res = a * b;
                break;
            case '/':
                res = a / b;
                break;
            case '^':
                res = pow(a, b);
                break;
            }

            s.push(res);
        }
    }

    if (s.empty())
    {
        cout << "Error: Stack Empty (no result available)" << endl;
        return 0;
    }

    return s.top();
}

int main()
{
    string infix, postfix, prefix;
    int choice;

    do
    {
        cout << endl
             << "--- Infix to Postfix/Prefix Converter & Evaluator ---" << endl;
        cout << "1. Enter Infix Expression" << endl;
        cout << "2. Convert Infix to Postfix" << endl;
        cout << "3. Convert Infix to Prefix" << endl;
        cout << "4. Evaluate Postfix Expression" << endl;
        cout << "5. Evaluate Prefix Expression" << endl;
        cout << "0. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice)
        {
        case 1:
            cout << "Enter infix expression (e.g., (A+B)*(C-D)): ";
            cin >> infix;
            postfix = infixToPostfix(infix);
            prefix = infixToPrefix(infix);
            if (postfix != "" && prefix != "")
                cout << "Expression stored successfully." << endl;
            break;

        case 2:
            if (postfix != "")
                cout << "Postfix Expression: " << postfix << endl;
            else
                cout << "Postfix expression not available (conversion failed)." << endl;
            break;

        case 3:
            if (prefix != "")
                cout << "Prefix Expression: " << prefix << endl;
            else
                cout << "Prefix expression not available (conversion failed)." << endl;
            break;

        case 4:
        {
            if (postfix != "")
            {
                cout << "Evaluating Postfix Expression:" << endl;
                int result = evaluatePostfix(postfix);
                cout << "Result: " << result << endl;
            }
            else
            {
                cout << "Cannot evaluate. Postfix expression is invalid or empty." << endl;
            }
            break;
        }

        case 5:
        {
            if (prefix != "")
            {
                cout << "Evaluating Prefix Expression:" << endl;
                int result = evaluatePrefix(prefix);
                cout << "Result: " << result << endl;
            }
            else
            {
                cout << "Cannot evaluate. Prefix expression is invalid or empty." << endl;
            }
            break;
        }

        case 0:
            cout << "Exiting..." << endl;
            break;

        default:
            cout << "Invalid choice. Please try again." << endl;
        }

    } while (choice != 0);

    return 0;
}
